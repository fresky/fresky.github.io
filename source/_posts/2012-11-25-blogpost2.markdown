---
layout: post
title: "C++编译器什么时候为我们自动生成拷贝构造函数？"
date: 2012-11-25
comments: true
categories: 
---
<p>StackOverflow上有个一个有趣的问题，<a href="http://stackoverflow.com/questions/13374984/c-copy-by-value-to-function-params-produce-two-objects-in-vs2012/13551240#13551240">copy by value to function params produce two objects in vs2012</a></p>  <p>给出程序：</p>  <div style="border-bottom: #cccccc 1px solid; border-left: #cccccc 1px solid; padding-bottom: 5px; background-color: #f5f5f5; padding-left: 5px; padding-right: 5px; border-top: #cccccc 1px solid; border-right: #cccccc 1px solid; padding-top: 5px" class="cnblogs_code">   <pre>#include &lt;iostream&gt;

<span style="color: #0000ff">using</span> <span style="color: #0000ff">namespace</span><span style="color: #000000"> std;

</span><span style="color: #0000ff">class</span><span style="color: #000000"> A
{
</span><span style="color: #0000ff">public</span><span style="color: #000000">:
    A() { cout </span>&lt;&lt; <span style="color: #800000">&quot;</span><span style="color: #800000">1</span><span style="color: #800000">&quot;</span> &lt;&lt;<span style="color: #000000"> endl; }
    </span>~A() { cout &lt;&lt; <span style="color: #800000">&quot;</span><span style="color: #800000">2</span><span style="color: #800000">&quot;</span> &lt;&lt;<span style="color: #000000"> endl; }
};

</span><span style="color: #0000ff">class</span> B : <span style="color: #0000ff">public</span><span style="color: #000000"> A
{
</span><span style="color: #0000ff">public</span><span style="color: #000000">:
    B() { cout </span>&lt;&lt; <span style="color: #800000">&quot;</span><span style="color: #800000">3</span><span style="color: #800000">&quot;</span> &lt;&lt;<span style="color: #000000"> endl; }
    </span>~B() { cout &lt;&lt; <span style="color: #800000">&quot;</span><span style="color: #800000">4</span><span style="color: #800000">&quot;</span> &lt;&lt;<span style="color: #000000"> endl; }
};

</span><span style="color: #0000ff">void</span><span style="color: #000000"> func(A a) {}

</span><span style="color: #0000ff">int</span><span style="color: #000000"> main()
{
    B b;
    func(b);
    </span><span style="color: #0000ff">return</span> <span style="color: #800080">0</span><span style="color: #000000">;
}</span></pre>
</div>

<p>Visual Studio给出的输出是：132242。</p>

<p>前两个13和最后两个42.是对应的，分别是main函数中的局部变量b的构造和析构。问题出在中间的两个2，说明在调用函数func的时候创建了两个临时的A。</p>

<p>看到这个程序，第一眼的感觉应该是：因为func是参数是值传递，所以b传给func时，调用了A的拷贝构造函数，从b生成了一个A的临时变量，推出func时，这个临时变量析构，所以应该只有一个2.</p>

<p>&#160;</p>

<p>但是为什么会有两次呢？打开disassembly window，我们可以看到如下的汇编代码：</p>

<div style="border-bottom: #cccccc 1px solid; border-left: #cccccc 1px solid; padding-bottom: 5px; background-color: #f5f5f5; padding-left: 5px; padding-right: 5px; border-top: #cccccc 1px solid; border-right: #cccccc 1px solid; padding-top: 5px" class="cnblogs_code">
  <pre>B b<span style="color: #008000">;
</span><span style="color: #800080">00B317F8</span>  <span style="color: #0000ff">lea</span><span style="color: #000000">         ecx,[b]  
</span><span style="color: #800080">00B317FB</span>  <span style="color: #0000ff">call</span>        <span style="color: #008080">B:</span><span style="color: #000000">:B (0B31650h)  
</span><span style="color: #800080">00B31800</span>  <span style="color: #0000ff">mov</span>         dword ptr [ebp-<span style="color: #800080">4</span>],<span style="color: #800080">0</span><span style="color: #000000">  
func(b)</span><span style="color: #008000">;
</span><span style="color: #800080">00B31807</span>  <span style="color: #0000ff">mov</span><span style="color: #000000">         al,byte ptr [ebp-12h]  
</span><span style="color: #800080">00B3180A</span>  <span style="color: #0000ff">mov</span><span style="color: #000000">         byte ptr [ebp-13h],al  
</span><span style="color: #800080">00B3180D</span>  <span style="color: #0000ff">mov</span>         byte ptr [ebp-<span style="color: #800080">4</span>],<span style="color: #800080">1</span>  
<span style="color: #800080">00B31811</span>  <span style="color: #0000ff">movzx</span><span style="color: #000000">       ecx,byte ptr [ebp-13h]  
</span><span style="color: #800080">00B31815</span>  <span style="color: #0000ff">push</span><span style="color: #000000">        ecx  
</span><span style="color: #800080">00B31816</span>  <span style="color: #0000ff">call</span>        func (0B31730h)</pre>
</div>



<p>如果我们把原来的程序的中A的析构函数改成virtual，这样，输出的结果就是13242，中间只有1个2，说明只有一个临时的A被创建了出来，是我们期望的结果。汇编代码如下：</p>

<div style="border-bottom: #cccccc 1px solid; border-left: #cccccc 1px solid; padding-bottom: 5px; background-color: #f5f5f5; padding-left: 5px; padding-right: 5px; border-top: #cccccc 1px solid; border-right: #cccccc 1px solid; padding-top: 5px" class="cnblogs_code">
  <pre>B b<span style="color: #008000">;
</span><span style="color: #800080">00331898</span>  <span style="color: #0000ff">lea</span><span style="color: #000000">         ecx,[b]  
</span><span style="color: #800080">0033189B</span>  <span style="color: #0000ff">call</span>        <span style="color: #008080">B:</span><span style="color: #000000">:B (03316A0h)  
</span><span style="color: #800080">003318A0</span>  <span style="color: #0000ff">mov</span>         dword ptr [ebp-<span style="color: #800080">4</span>],<span style="color: #800080">0</span><span style="color: #000000">  
func(b)</span><span style="color: #008000">;
</span><span style="color: #800080">003318A7</span>  <span style="color: #0000ff">push</span><span style="color: #000000">        ecx  
</span><span style="color: #800080">003318A8</span>  <span style="color: #0000ff">mov</span><span style="color: #000000">         ecx,esp  
</span><span style="color: #800080">003318AA</span>  <span style="color: #0000ff">mov</span><span style="color: #000000">         dword ptr [ebp-1Ch],esp  
</span><span style="color: #800080">003318AD</span>  <span style="color: #0000ff">lea</span><span style="color: #000000">         eax,[b]  
</span><span style="color: #800080">003318B0</span>  <span style="color: #0000ff">push</span><span style="color: #000000">        eax  
</span><span style="color: #800080">003318B1</span>  <span style="color: #0000ff">call</span>        <span style="color: #008080">A:</span><span style="color: #000000">:A (0331900h)  
</span><span style="color: #800080">003318B6</span>  <span style="color: #0000ff">mov</span><span style="color: #000000">         dword ptr [ebp-20h],eax  
</span><span style="color: #800080">003318B9</span>  <span style="color: #0000ff">call</span>        func (03317D0h)</pre>
</div>

<p>回想Inside C++ object model中说到的只有在4中情况下编译器才会给我们生成缺省拷贝构造函数：</p>

<ol>
  <li>类包含的成员变量是object，并且这个object的类有拷贝构造函数。</li>

  <li>类继承自一个基类，这个基类有拷贝构造函数。</li>

  <li>类声明了1个或者多个虚函数。</li>

  <li>类继承自一个基类，这个基类有1个或者多个虚函数。</li>
</ol>

<p>所以在原来的代码中A不属于上面4类，所以编译器不会为它生成一个缺省拷贝构造函数。</p>

<p>我把我的理解写在了这个<a href="http://stackoverflow.com/a/13551240/304115">答案</a>里。</p>