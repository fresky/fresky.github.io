---
layout: post
title: "C#中如何正确的实现IDisposable接口"
date: 2012-12-23
comments: true
categories: 
---
<p>Stackoverflow上的这个<a href="http://stackoverflow.com/a/538238/304115">回答</a>是我见过的讲的最清楚的怎么正确实现<span style="color: #000000;">IDisposable</span>接口，我简单挑重点翻译翻译吧。：）</p>
<h3>&nbsp;</h3>
<p>Disposed的出现就是要解决一个问题，那就是释放非托管的资源。.NET的垃圾回收不知道怎么去释放非托管的资源。</p>
<p>所以，如果你的对象中有非托管的资源，你就需要提供一个函数给外面的人来释放它。我们有一个标准的名字：</p>
<div class="cnblogs_code" style="background-color: #f5f5f5; border: #cccccc 1px solid; padding: 5px;">
<pre><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">void</span> Dispose()</pre>
</div>
<p>在C#中有个接口，只包含了这个函数，所以如果你的类需要释放非托管资源，就需要实现这个接口，实现了这个借口，意味着你承诺在Dispose方法中释放非托管资源。</p>
<div class="cnblogs_code" style="background-color: #f5f5f5; border: #cccccc 1px solid; padding: 5px;">
<pre><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">interface</span><span style="color: #000000;"> IDisposable
{
    </span><span style="color: #0000ff;">void</span><span style="color: #000000;"> Dispose();
}</span></pre>
</div>
<p>下面是个释放非托管资源的例子。</p>
<div class="cnblogs_code" style="background-color: #f5f5f5; border: #cccccc 1px solid; padding: 5px;">
<pre><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">void</span><span style="color: #000000;"> Dispose()
{
   Win32.DestroyHandle(</span><span style="color: #0000ff;">this</span><span style="color: #000000;">.gdiCursorBitmapStreamFileHandle);
}</span></pre>
</div>
<p>这其实就搞定了：）但是你可以做的更好。</p>
<h3>&nbsp;</h3>
<p>如果你的对象中有托管的资源，而且很大，比如有个250m的bitmap。当然C#的垃圾回收会把它释放掉，但是更好的是我们能在不需要的时候就把它释放掉而不必等到垃圾回收。怎么做呢？我们已经有了一个方法来释放非托管的资源，好办，我们把在Dispose中把托管的资源也释放掉就好了，这样我们的Dispose干两件事情：</p>
<ol>
<li>释放非托管资源，因为必须</li>
<li>释放托管资源，因为这样好：）</li>
</ol>
<p>新的Dispose函数长这个样子：</p>
<div class="cnblogs_code" style="background-color: #f5f5f5; border: #cccccc 1px solid; padding: 5px;">
<pre><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">void</span><span style="color: #000000;"> Dispose()
{
   </span><span style="color: #008000;">//</span><span style="color: #008000;">Free unmanaged resources</span>
   Win32.DestroyHandle(<span style="color: #0000ff;">this</span><span style="color: #000000;">.gdiCursorBitmapStreamFileHandle);

   </span><span style="color: #008000;">//</span><span style="color: #008000;">Free managed resources too</span>
   <span style="color: #0000ff;">if</span> (<span style="color: #0000ff;">this</span>.databaseConnection != <span style="color: #0000ff;">null</span><span style="color: #000000;">)
   {
      </span><span style="color: #0000ff;">this</span><span style="color: #000000;">.databaseConnection.Dispose();
      </span><span style="color: #0000ff;">this</span>.databaseConnection = <span style="color: #0000ff;">null</span><span style="color: #000000;">;
   }
   </span><span style="color: #0000ff;">if</span> (<span style="color: #0000ff;">this</span>.frameBufferImage != <span style="color: #0000ff;">null</span><span style="color: #000000;">)
   {
      </span><span style="color: #0000ff;">this</span><span style="color: #000000;">.frameBufferImage.Dispose();
      </span><span style="color: #0000ff;">this</span>.frameBufferImage = <span style="color: #0000ff;">null</span><span style="color: #000000;">;
   }
}</span></pre>
</div>
<p>看起来搞定了，但是，我们可以做的更好！</p>
<h3>&nbsp;</h3>
<p>如果我们的使用者没有调用Dispose怎么办呢？我们就会有资源泄露了！（当然只有非托管的资源泄露，因为托管的C#的垃圾回收会帮我们搞定它）</p>
<p>嗯，我们把这个Dispose放到Finalize里面，这样我的对象被销毁的时候，它就能自动调到，不错，代码如下：</p>
<div class="cnblogs_code" style="background-color: #f5f5f5; border: #cccccc 1px solid; padding: 5px;">
<pre>~<span style="color: #000000;">MyObject()
{
    </span><span style="color: #008000;">//</span><span style="color: #008000;">we're being finalized (i.e. destroyed), call Dispose in case the user forgot to</span>
    Dispose(); <span style="color: #008000;">//</span><span style="color: #008000;">&lt;--Warning: subtle bug! Keep reading!</span>
}</pre>
</div>
<p>但是，我们可能会引入一个bug。因为C#地垃圾回收是在后台运行，我们不知道它会先回收哪个对象，所以我们的对象中包含的托管资源可能已经被回收掉了，就会发生：</p>
<div class="cnblogs_code" style="background-color: #f5f5f5; border: #cccccc 1px solid; padding: 5px;">
<pre><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">void</span><span style="color: #000000;"> Dispose()
{
   </span><span style="color: #008000;">//</span><span style="color: #008000;">Free unmanaged resources</span>
   Win32.DestroyHandle(<span style="color: #0000ff;">this</span><span style="color: #000000;">.gdiCursorBitmapStreamFileHandle);

   </span><span style="color: #008000;">//</span><span style="color: #008000;">Free managed resources too</span>
   <span style="color: #0000ff;">if</span> (<span style="color: #0000ff;">this</span>.databaseConnection != <span style="color: #0000ff;">null</span><span style="color: #000000;">)
   {
      </span><span style="color: #0000ff;">this</span>.databaseConnection.Dispose(); &lt;--<span style="color: #000000;"> crash, GC already destroyed it
      </span><span style="color: #0000ff;">this</span>.databaseConnection = <span style="color: #0000ff;">null</span><span style="color: #000000;">;
   }
   </span><span style="color: #0000ff;">if</span> (<span style="color: #0000ff;">this</span>.frameBufferImage != <span style="color: #0000ff;">null</span><span style="color: #000000;">)
   {
      </span><span style="color: #0000ff;">this</span>.frameBufferImage.Dispose(); &lt;--<span style="color: #000000;"> crash, GC already destroyed it
      </span><span style="color: #0000ff;">this</span>.frameBufferImage = <span style="color: #0000ff;">null</span><span style="color: #000000;">;
   }
}</span></pre>
</div>
<p>所以我们需要一种办法让在Finalize中调到的Dispose函数不去释放托管的资源，留给垃圾回收来做，我们习惯用这样的函数来实现：</p>
<div class="cnblogs_code" style="background-color: #f5f5f5; border: #cccccc 1px solid; padding: 5px;">
<pre><span style="color: #0000ff;">protected</span> <span style="color: #0000ff;">void</span> Dispose(Boolean disposing)</pre>
</div>
<p>这个参数名字disposing有点不太好，我们改个名字吧：） </p>
<div class="cnblogs_code" style="background-color: #f5f5f5; border: #cccccc 1px solid; padding: 5px;">
<pre><span style="color: #0000ff;">protected</span> <span style="color: #0000ff;">void</span><span style="color: #000000;"> Dispose(Boolean freeManagedObjectsAlso)
{
   </span><span style="color: #008000;">//</span><span style="color: #008000;">Free unmanaged resources</span>
   Win32.DestroyHandle(<span style="color: #0000ff;">this</span><span style="color: #000000;">.gdiCursorBitmapStreamFileHandle);

   </span><span style="color: #008000;">//</span><span style="color: #008000;">Free managed resources too, but only if i'm being called from Dispose
   </span><span style="color: #008000;">//</span><span style="color: #008000;">(If i'm being called from Finalize then the objects might not exist
   </span><span style="color: #008000;">//</span><span style="color: #008000;">anymore</span>
   <span style="color: #0000ff;">if</span><span style="color: #000000;"> (freeManagedObjectsAlso)  
   {    
      </span><span style="color: #0000ff;">if</span> (<span style="color: #0000ff;">this</span>.databaseConnection != <span style="color: #0000ff;">null</span><span style="color: #000000;">)
      {
         </span><span style="color: #0000ff;">this</span><span style="color: #000000;">.databaseConnection.Dispose();
         </span><span style="color: #0000ff;">this</span>.databaseConnection = <span style="color: #0000ff;">null</span><span style="color: #000000;">;
      }
      </span><span style="color: #0000ff;">if</span> (<span style="color: #0000ff;">this</span>.frameBufferImage != <span style="color: #0000ff;">null</span><span style="color: #000000;">)
      {
         </span><span style="color: #0000ff;">this</span><span style="color: #000000;">.frameBufferImage.Dispose();
         </span><span style="color: #0000ff;">this</span>.frameBufferImage = <span style="color: #0000ff;">null</span><span style="color: #000000;">;
      }
   }
}</span></pre>
</div>
<p>所以我们先前写的Dispose函数变成了这样：</p>
<div class="cnblogs_code" style="background-color: #f5f5f5; border: #cccccc 1px solid; padding: 5px;">
<pre><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">void</span><span style="color: #000000;"> Dispose()
{
   Dispose(</span><span style="color: #0000ff;">true</span>); <span style="color: #008000;">//</span><span style="color: #008000;">i am calling you from Dispose, it's safe</span>
<span style="color: #000000;">}

</span><span style="color: #0000ff;">public</span> ~<span style="color: #000000;">MyObject()
{
   Dispose(</span><span style="color: #0000ff;">false</span>); <span style="color: #008000;">//</span><span style="color: #008000;">i am *not* calling you from Dispose, it's *not* safe</span>
}</pre>
</div>
<p>提醒一下，如果我们的类的父类也是IDisposable的，我们需要调用父类的Dispose函数。</p>
<div class="cnblogs_code" style="background-color: #f5f5f5; border: #cccccc 1px solid; padding: 5px;">
<pre><span style="color: #0000ff;">public</span><span style="color: #000000;"> Dispose()
{
   </span><span style="color: #0000ff;">try</span><span style="color: #000000;">
   {
      Dispose(</span><span style="color: #0000ff;">true</span>); <span style="color: #008000;">//</span><span style="color: #008000;">true: safe to free managed resources</span>
<span style="color: #000000;">   }
   </span><span style="color: #0000ff;">finally</span><span style="color: #000000;">
   {
      </span><span style="color: #0000ff;">base</span><span style="color: #000000;">.Dispose();
   }
}</span></pre>
</div>
<p>看起来搞定了，但是我们可以做的更好！</p>
<h3>&nbsp;</h3>
<p>如果我们的客户代码调用了Dispose，那意味着托管和非托管的资源都被释放掉了，但是随后C#的垃圾回收还会再次调用Dispose。不仅仅是浪费，而且如果万一我们没有在Dispose非托管资源时把它设成null，就是说它还指着东西，那就会被再释放一次，这可不是好玩的。</p>
<div class="cnblogs_code" style="background-color: #f5f5f5; border: #cccccc 1px solid; padding: 5px;">
<pre><span style="color: #0000ff;">protected</span> <span style="color: #0000ff;">void</span><span style="color: #000000;"> Dispose(Boolean iAmBeingCalledFromDisposeAndNotFinalize)
{
   </span><span style="color: #008000;">//</span><span style="color: #008000;">Free unmanaged resources</span>
   Win32.DestroyHandle(<span style="color: #0000ff;">this</span>.gdiCursorBitmapStreamFileHandle); &lt;--<span style="color: #0000ff;">double</span><span style="color: #000000;"> destroy 
   ...
}</span></pre>
</div>
<p>修改这个问题的方法就是，如果已经调用过Dispose了，就不要再调Finalize了。</p>
<div class="cnblogs_code" style="background-color: #f5f5f5; border: #cccccc 1px solid; padding: 5px;">
<pre><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">void</span><span style="color: #000000;"> Dispose()
{
   Dispose(</span><span style="color: #0000ff;">true</span>); <span style="color: #008000;">//</span><span style="color: #008000;">i am calling you from Dispose, it's safe</span>
   GC.SuppressFinalize(<span style="color: #0000ff;">this</span>); <span style="color: #008000;">//</span><span style="color: #008000;">Hey, GC: don't bother calling finalize later</span>
}</pre>
</div>
<p>好了，万事大吉：）</p>