---
layout: post
title: "C#中静态构造函数导致的一个deadlock"
date: 2013-02-05
comments: true
categories: 
---
<p id="site-description">Eric Lipper的这篇<a href="http://ericlippert.com/2013/01/31/the-no-lock-deadlock/" target="_blank">博客</a>举了一个C#中静态构造函数导致的deadlock的例子，很有意思。</p>
<p>代码如下：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> C
{
  </span><span style="color: #0000ff;">static</span><span style="color: #000000;"> C() 
  {
    </span><span style="color: #008000;">//</span><span style="color: #008000;"> Let's run the initialization on another thread!</span>
    <span style="color: #0000ff;">var</span> thread = <span style="color: #0000ff;">new</span><span style="color: #000000;"> System.Threading.Thread(Initialize);
    thread.Start();
    thread.Join();
  }
  </span><span style="color: #0000ff;">static</span> <span style="color: #0000ff;">void</span><span style="color: #000000;"> Initialize() { }
  </span><span style="color: #0000ff;">static</span> <span style="color: #0000ff;">void</span><span style="color: #000000;"> Main() { }
}</span></pre>
</div>
<p>原因很简单，静态构造函数需要在第一次用到这个类静态方法或者实例之前调用结束，就是说C（）在等Initialize（），但是Initialize（）必须在C()结束后才能被调到。</p>