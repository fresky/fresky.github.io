---
layout: post
title: "C#的强迫执行域Constrained Execution Regions(CERs)"
date: 2013-06-07
comments: true
categories: 
---
<p>强迫执行域（CERs）通常用于遇到未预见的异常时，保证系统被多个AppDomain或者进程共享的状态的正确性。</p>
<p>这种异常我们通常称之为Asynchronous Exception。比如当调用一个函数时，CLR需要去加载assembly，在AppDomain的堆上创建类型，调用类型的类构造函数，JIT把IL转换成native代码等等。当这些过程出错时，CLR会抛异常。如果这个异常是在代码的catch或者finally抛出的话，catch和finally中的错误恢复代码就不能被执行了，这样系统的状态就有可能会出错。</p>
<p>考虑如下的代码示例：</p>
<div class="cnblogs_code">
<pre><span style="color: #008080;"> 1</span>     <span style="color: #0000ff;">sealed</span> <span style="color: #0000ff;">class</span><span style="color: #000000;"> Type1
</span><span style="color: #008080;"> 2</span> <span style="color: #000000;">    {
</span><span style="color: #008080;"> 3</span>         <span style="color: #0000ff;">static</span><span style="color: #000000;"> Type1()
</span><span style="color: #008080;"> 4</span> <span style="color: #000000;">        {
</span><span style="color: #008080;"> 5</span>             <span style="color: #008000;">//</span><span style="color: #008000;"> throw new ApplicationException("if this throws an exception, M won&rsquo;t get called");</span>
<span style="color: #008080;"> 6</span>             Console.WriteLine(<span style="color: #800000;">"</span><span style="color: #800000;">Type1's static ctor called</span><span style="color: #800000;">"</span><span style="color: #000000;">);
</span><span style="color: #008080;"> 7</span> <span style="color: #000000;">        }
</span><span style="color: #008080;"> 8</span> 
<span style="color: #008080;"> 9</span> <span style="color: #ff0000;">        [ReliabilityContract(Consistency.WillNotCorruptState, Cer.Success)]
</span><span style="color: #008080;">10</span>         <span style="color: #0000ff;">public</span> <span style="color: #0000ff;">static</span> <span style="color: #0000ff;">void</span><span style="color: #000000;"> M()
</span><span style="color: #008080;">11</span> <span style="color: #000000;">        {
</span><span style="color: #008080;">12</span>             Console.WriteLine(<span style="color: #800000;">"</span><span style="color: #800000;">Type1's M</span><span style="color: #800000;">"</span><span style="color: #000000;">);
</span><span style="color: #008080;">13</span> <span style="color: #000000;">        }
</span><span style="color: #008080;">14</span> <span style="color: #000000;">    }
</span><span style="color: #008080;">15</span> 
<span style="color: #008080;">16</span>         <span style="color: #0000ff;">static</span> <span style="color: #0000ff;">void</span><span style="color: #000000;"> CER()
</span><span style="color: #008080;">17</span> <span style="color: #000000;">        {
</span><span style="color: #008080;">18</span> <span style="color: #ff0000;">            RuntimeHelpers.PrepareConstrainedRegions();
</span><span style="color: #008080;">19</span>             <span style="color: #0000ff;">try</span>
<span style="color: #008080;">20</span> <span style="color: #000000;">            {
</span><span style="color: #008080;">21</span>                 Console.WriteLine(<span style="color: #800000;">"</span><span style="color: #800000;">In try</span><span style="color: #800000;">"</span><span style="color: #000000;">);
</span><span style="color: #008080;">22</span> <span style="color: #000000;">            }
</span><span style="color: #008080;">23</span>             <span style="color: #0000ff;">finally</span>
<span style="color: #008080;">24</span> <span style="color: #000000;">            {
</span><span style="color: #008080;">25</span>                 <span style="color: #008000;">//</span><span style="color: #008000;"> Type1&rsquo;s static constructor is implicitly called in here</span>
<span style="color: #008080;">26</span> <span style="color: #000000;">                Type1.M();
</span><span style="color: #008080;">27</span> <span style="color: #000000;">            }
</span><span style="color: #008080;">28</span>         }</pre>
</div>
<p>第9行和第18行使用了CER，需要<span style="color: #0000ff;">using</span><span style="color: #000000;"> System.Runtime.CompilerServices; 和</span><span style="color: #0000ff;">using</span> System.Runtime.ConstrainedExecution;。当JIT编译器看到CERs时，会先编译catch和finally中的代码。JIT会加载需要的assembly，创建对象，调用类构造函数，JIT所有的方法。如果任何一步出了异常，那么这个异常会在try代码块之前抛出，从而保证了系统的状态始终是正确的。<span style="color: blue;"><br /></span></p>
<p>运行上面的代码，可以得到如下的输出：</p>
<div class="cnblogs_Highlighter">
<pre class="brush:csharp;gutter:false;">Type1's static ctor called
In try
Type1's M
</pre>
</div>
<p>&nbsp;如果注释掉第9行和第18行，得到的输出如下：</p>
<div class="cnblogs_Highlighter">
<pre class="brush:csharp;gutter:false;">In try
Type1's static ctor called
Type1's M
</pre>
</div>
<p>&nbsp;</p>
<p>补充几个关于Exception的小知识：</p>
<p><br />1. 在watch窗口输入$exception，可以看到CLR的exception信息。对于C++，可以在watch窗口输入@err,hr，相当于显示上一次调用API后再调用GetLastError。输入@eax，hr显示eax寄存器的值，由于win的API的返回值放在eax中，所以这句话的意思就是的到最近一个API的返回值。另外，如果你需要看的是一个array，你可以通过在watch中写 array, 3来看数组的前3个值。<br />2. 可以监听AppDomain的FirstChanceException事件来找到exception的第一现场。<br />3. 如果想先catch在throw。应该用catch(e){throw;} 而不是 catch(e){throw e;}。<br />4. 在函数前加属性[MethodImpl](MethodImplOptions.NoInlining)] 可以强迫JIT在异常抛出时不要inline这个方法。我在之前的博客中介绍过如何使用debugger attribute来定制在Visual Studio中的信息。参见&ldquo;<a href="http://www.cnblogs.com/fresky/archive/2012/07/16/2593299.html">定制自己的Visual Studio的Debugger Visualizer</a>&rdquo;和&ldquo;<a href="http://www.cnblogs.com/fresky/articles/2133378.html">定制C#在Visual Studio中的debug信息</a>&rdquo;。<br />5. 可以调用 SetErrorMode(SEM_NOGPFAULTERRORBOX) 来禁用Windows Error Reporting，就是出错后问你要不要发送出错信息的那个对话框。</p>